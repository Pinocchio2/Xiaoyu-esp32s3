
我需要仔细查看系统崩溃的问题。从对话历史可以看到，之前有 LoadProhibited 错误发生在 LcdDisplay::SetEmotion 函数中，以及编译错误涉及 dual_animation.cc 文件中的图像变量未声明。让我先搜索最新的错误信息和崩溃日志。
        
            
toolName: search_by_regex
            
status: success
          
          
搜索结果显示了一些常规的错误处理代码，但没有找到具体的系统崩溃日志。让我搜索更具体的ESP32崩溃相关信息，包括堆栈跟踪和内存错误。
        
            
toolName: search_by_regex
            
status: success
          
          
没有找到具体的崩溃日志。让我查看dual_animation.cc文件，因为从对话历史可以看到这里有编译错误，可能是导致系统问题的原因。
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\boards\yuwell-xiaoyu-esp32s3-double-lcd\dual_animation.cc
          
dual_animation.cc文件不存在。让我检查双屏板卡目录下的实际文件结构。
        
            
toolName: view_folder
            
status: success
          
d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\boards\yuwell-xiaoyu-esp32s3-double-lcd
          
确实没有dual_animation.cc文件。让我查看yuwell_xiaoyu_esp32s3_double_lcd.cc文件，看看双屏板卡的实现和可能的问题。
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\boards\yuwell-xiaoyu-esp32s3-double-lcd\yuwell_xiaoyu_esp32s3_double_lcd.cc
          
让我查看GetDisplay()方法的实现，因为从对话历史可以看到这里可能返回nullptr导致崩溃。
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\boards\yuwell-xiaoyu-esp32s3-double-lcd\yuwell_xiaoyu_esp32s3_double_lcd.cc
          
现在GetDisplay()方法返回eye_display_，这是好的。让我检查EyeAnimationDisplay的SetEmotion方法实现，看看是否有问题。
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.cc
          
SetEmotion方法看起来正常。让我检查EmotionManager的实现，看看是否在获取动画时有问题。
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\emotion_manager.cc
          
让我查看InitializeAnimations方法，看看是否正确初始化了所有动画，特别是closed_eyes动画。
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\emotion_manager.cc
          
EmotionManager看起来正常，closed_eyes动画已经注册。让我检查是否有编译错误或者其他问题。让我搜索最近的编译日志或错误信息。
        
            
toolName: search_by_regex
            
status: success
          
          
搜索结果显示了很多正常的错误处理代码，但没有找到具体的崩溃日志。让我搜索更具体的ESP32崩溃关键词，如LoadProhibited、Guru Meditation等。
        
            
toolName: search_by_regex
            
status: success
          
          
搜索结果显示了一些assert语句和看门狗配置，但仍然没有找到具体的崩溃日志。让我检查是否有最近的构建日志或者运行时日志文件。
        
            
toolName: search_by_regex
            
status: success
          
          
没有找到具体的崩溃日志文件。让我检查dual_animation相关的代码，看看是否存在内存访问问题或空指针引用。先查看dual_display_manager的实现。
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\boards\yuwell-xiaoyu-esp32s3-double-lcd\dual_display_manager.cc
          
DualDisplayManager的代码看起来相对正常，但我注意到在SetImage函数中有一些潜在问题。让我查看eye_animation_display.cc中的具体实现，看看是否存在空指针或内存访问问题。
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.cc
          
我看到了一些潜在问题。在EyeAnimationDisplay构造函数中，代码尝试将Display*强制转换为LcdDisplay*，这可能导致类型不匹配。让我查看PlayNextFrame函数的实现，这里可能存在内存访问问题。
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.cc
          
我发现了几个潜在的问题。让我查看update_image_callback函数的实现，这个函数在LVGL异步调用中使用，可能存在线程安全问题。
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.cc
          
现在让我查看PlayAnimation函数的实现，这个函数可能是崩溃的根源。
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.cc
          
让我查看animation_timer_callback函数的实现，这个回调函数可能存在问题。
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.cc
          
现在让我查看animation_task函数的完整实现，这个任务函数可能是崩溃的关键。
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.cc
          
现在让我查看析构函数的完整实现，看看资源清理是否正确。
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.cc
          
我发现了几个严重的问题。现在让我检查EyeAnimationDisplay的头文件，看看成员变量的定义。
        
            
toolName: search_codebase
            
status: success
          
query: EyeAnimationDisplay class definition and member variables in header file
          
现在让我查看完整的EyeAnimationDisplay头文件，特别是成员变量的定义。
        
            
toolName: view_files
            
status: success
          
            
filePath: d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.h
          
经过仔细分析代码，我发现了几个可能导致系统崩溃的严重问题：

## 🔍 主要问题分析

### 1. **类型转换错误**
在 <mcfile name="eye_animation_display.cc" path="d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.cc"></mcfile> 的构造函数中：

```cpp:d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.cc
// 问题代码：强制类型转换可能导致崩溃
LcdDisplay* lcd_primary = static_cast<LcdDisplay*>(primary_display);
LcdDisplay* lcd_secondary = static_cast<LcdDisplay*>(secondary_display);
```

**问题**：`DualDisplayManager` 返回的是 `SpiLcdDisplay` 对象，但代码强制转换为 `LcdDisplay*`，这可能导致虚函数表错误和内存访问违规。

### 2. **静态成员变量的线程安全问题**

```cpp:d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.cc
// 问题：静态成员在多线程环境下不安全
static ImageUpdateData left_eye_data_;
static ImageUpdateData right_eye_data_;
```

**问题**：多个 `EyeAnimationDisplay` 实例会共享这些静态变量，在并发访问时可能导致数据竞争。

### 3. **析构函数中的锁定问题**

```cpp:d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.cc
// 问题：析构时使用this指针作为锁
DisplayLockGuard lock(this);
```

**问题**：在析构函数中，对象可能已经部分销毁，使用 `this` 指针可能导致未定义行为。

### 4. **LVGL异步调用的内存安全问题**

```cpp:d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.cc
lv_async_call(update_image_callback, &left_eye_data_);
```

**问题**：传递静态变量地址给异步回调，如果对象在回调执行前被销毁，会导致访问无效内存。

## 🛠️ 解决方案

### 1. 修复类型转换问题

```cpp:d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.cc
EyeAnimationDisplay::EyeAnimationDisplay() {
    ESP_LOGI(TAG, "初始化眼睛动画显示");
    
    // 确保LVGL已经初始化
    if (!lv_is_initialized()) {
        ESP_LOGE(TAG, "LVGL未初始化");
        return;
    }
    
    // 获取双屏管理器
    if (!g_dual_display_manager) {
        ESP_LOGE(TAG, "双屏管理器未初始化");
        return;
    }
    
    // 直接使用DualDisplayManager的方法创建图像对象
    primary_display_ = g_dual_display_manager->GetPrimaryDisplay();
    secondary_display_ = g_dual_display_manager->GetSecondaryDisplay();
    
    if (!primary_display_ || !secondary_display_) {
        ESP_LOGE(TAG, "无法获取双屏显示对象");
        return;
    }
    
    // 使用DualDisplayManager的安全方法创建UI
    InitializeEyeObjects();
    
    // 创建动画任务
    xTaskCreate(
        animation_task,
        "eye_anim_task",
        4096,
        this,
        3,
        &animation_task_handle_
    );
}

private:
void InitializeEyeObjects() {
    // 通过DualDisplayManager安全地初始化眼睛对象
    // 避免直接类型转换
    if (g_dual_display_manager) {
        // 让DualDisplayManager处理具体的对象创建
        left_eye_img_ = g_dual_display_manager->CreateImageObject(true);  // 主屏
        right_eye_img_ = g_dual_display_manager->CreateImageObject(false); // 副屏
    }
}
```

### 2. 修复静态成员变量问题

```cpp:d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.h
class EyeAnimationDisplay : public Display {
private:
    // 将静态成员改为实例成员，避免线程安全问题
    struct ImageUpdateData {
        lv_obj_t* img_obj;
        const void* img_src;
        EyeAnimationDisplay* instance; // 添加实例指针
    };
    
    ImageUpdateData left_eye_data_;   // 实例成员
    ImageUpdateData right_eye_data_;  // 实例成员
};
```

### 3. 修复析构函数

```cpp:d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.cc
EyeAnimationDisplay::~EyeAnimationDisplay() {
    ESP_LOGI(TAG, "销毁眼睛动画显示");
    
    // 首先停止所有活动
    StopAnimation();
    
    // 删除任务
    if (animation_task_handle_) {
        vTaskDelete(animation_task_handle_);
        animation_task_handle_ = nullptr;
    }
    
    // 删除定时器
    if (animation_timer_) {
        esp_timer_delete(animation_timer_);
        animation_timer_ = nullptr;
    }
    
    // 安全清理LVGL对象 - 不使用this指针锁定
    if (primary_display_ && left_eye_img_) {
        DisplayLockGuard lock(primary_display_);
        lv_obj_del(left_eye_img_);
        left_eye_img_ = nullptr;
    }
    
    if (secondary_display_ && right_eye_img_) {
        DisplayLockGuard lock(secondary_display_);
        lv_obj_del(right_eye_img_);
        right_eye_img_ = nullptr;
    }
}
```

### 4. 修复异步调用问题

```cpp:d:\JUNE\Github-xiaoyu\Xiaoyu-esp32s3\main\display\eye_animation_display.cc
void EyeAnimationDisplay::PlayNextFrame() {
    if (!current_animation_ || current_frame_index_ >= static_cast<int>(current_animation_->frames.size())) {
        ESP_LOGW(TAG, "无效的动画状态");
        return;
    }

    const auto& frame = current_animation_->frames[current_frame_index_];

    // 使用实例成员而不是静态成员
    if (left_eye_img_ && frame.left_eye_image) {
        left_eye_data_.img_obj = left_eye_img_;
        left_eye_data_.img_src = frame.left_eye_image;
        left_eye_data_.instance = this; // 添加实例引用
        lv_async_call(update_image_callback, &left_eye_data_);
    }

    if (right_eye_img_ && frame.right_eye_image) {
        right_eye_data_.img_obj = right_eye_img_;
        right_eye_data_.img_src = frame.right_eye_image;
        right_eye_data_.instance = this; // 添加实例引用
        lv_async_call(update_image_callback, &right_eye_data_);
    }
    
    // ... 其余代码保持不变
}

void EyeAnimationDisplay::update_image_callback(void* user_data) {
    ImageUpdateData* data = static_cast<ImageUpdateData*>(user_data);
    if (data && data->img_obj && data->img_src && data->instance) {
        // 验证实例仍然有效
        lv_img_set_src(data->img_obj, data->img_src);
    }
}
```

## 🎯 建议的修复优先级

1. **立即修复**：类型转换问题（最可能导致LoadProhibited错误）
2. **高优先级**：静态成员变量线程安全问题
3. **中优先级**：析构函数锁定问题
4. **低优先级**：异步调用优化

## 🔧 额外建议

1. **添加更多错误检查**：在每个关键操作前验证指针有效性
2. **使用智能指针**：考虑使用RAII模式管理资源
3. **增加调试日志**：在关键路径添加更详细的日志
4. **内存对齐检查**：确保所有结构体正确对齐

这些修复应该能解决大部分导致系统崩溃的问题。建议按优先级逐步实施修复，并在每次修改后进行充分测试。
        