

# 核心步骤

1. 创建组件目录:

   在您的 xiaozhi-esp32 项目根目录下，创建一个名为 components 的文件夹（如果尚不存在）。

   在 components 文件夹内，再创建一个新的文件夹来存放 Edge Impulse 库，例如 edge_impulse_lib。

   所以，路径看起来像这样：xiaozhi-esp32/components/edge_impulse_lib/

2. 复制 Edge Impulse 文件:

   从您上传的 pinocchio2/wake_up-v3/wake_up-v3-06511904c4b6de119b71feb9fbb13c93ecc35929/ 文件夹中，找到以下三个核心文件夹：

   - `edge-impulse-sdk/`
   - `model-parameters/`
   - `tflite-model/` 将这三个文件夹**完整地**复制到刚刚创建的 `xiaozhi-esp32/components/edge_impulse_lib/` 目录下。

3. 为新组件创建 CMakeLists.txt:

   在 xiaozhi-esp32/components/edge_impulse_lib/ 目录下，创建一个名为 CMakeLists.txt 的文件。这个文件会告诉 ESP-IDF 构建系统如何编译这个组件。

   以下是一个 CMakeLists.txt 的模板，您需要根据实际情况调整：

   ```cmake
   # xiaozhi-esp32/components/edge_impulse_lib/CMakeLists.txt
   
   # 定义组件的源文件 (SRCS) 和包含目录 (INCLUDE_DIRS)
   # SRCS 需要包含 Edge Impulse SDK 和 TFLite 模型相关的 .c 和 .cpp 文件
   # INCLUDE_DIRS 需要指向所有头文件所在的目录
   
   # 基础的 Edge Impulse SDK 源文件 (根据 edge-impulse-sdk/sources.txt)
   # 注意：这里的路径是相对于当前 CMakeLists.txt 文件的
   set(EI_SDK_SRCS
       "edge-impulse-sdk/classifier/ei_run_classifier_c.cpp"
       "edge-impulse-sdk/dsp/memory.cpp"
       # ... 根据 edge-impulse-sdk/sources.txt 添加其他必要的 .cpp 或 .c 文件
       # 例如：
       # "edge-impulse-sdk/dsp/kissfft/kiss_fft.cpp"
       # "edge-impulse-sdk/dsp/kissfft/kiss_fftr.cpp"
       # "edge-impulse-sdk/dsp/spectral/processing.cpp" # 如果用到
       # ...等等，具体取决于您的模型和预处理块
   )
   
   # CMSIS-DSP 和 CMSIS-NN 源文件 (根据 edge-impulse-sdk/CMSIS/sources.txt)
   # 同样，路径是相对的
   set(CMSIS_SRCS
       # 例如:
       # "edge-impulse-sdk/CMSIS/DSP/Source/BasicMathFunctions/arm_add_f32.c"
       # "edge-impulse-sdk/CMSIS/NN/Source/ActivationFunctions/arm_relu_q7.c"
       # ... 根据 edge-impulse-sdk/CMSIS/sources.txt 添加实际使用的文件
   )
   
   # TFLite 模型源文件 (通常在 tflite-model/ 目录下)
   set(TFLITE_MODEL_SRCS
       "tflite-model/tflite_learn_3_compiled.cpp" # 这是您上传项目中的模型文件
   )
   
   # 合并所有源文件
   list(APPEND SRCS ${EI_SDK_SRCS} ${CMSIS_SRCS} ${TFLITE_MODEL_SRCS})
   
   # 定义头文件搜索路径
   set(INCLUDE_DIRS
       "." # 当前目录
       "edge-impulse-sdk"
       "edge-impulse-sdk/classifier"
       "edge-impulse-sdk/dsp"
       "edge-impulse-sdk/porting" # 通常包含平台相关的配置
       "edge-impulse-sdk/third_party/flatbuffers/include"
       "edge-impulse-sdk/third_party/gemmlowp"
       "edge-impulse-sdk/third_party/ruy"
       "edge-impulse-sdk/tensorflow/lite/micro/kernels/interface" # 如果您导出的模型是EON Compiler优化过的，则不需要
       "edge-impulse-sdk/tensorflow/lite/micro"
       "edge-impulse-sdk/tensorflow/lite/schema" # 通常不需要，但以防万一
       "edge-impulse-sdk/CMSIS/Core/Include"
       "edge-impulse-sdk/CMSIS/DSP/Include"
       "edge-impulse-sdk/CMSIS/NN/Include"
       "model-parameters"
       "tflite-model"
   )
   
   # 注册组件
   idf_component_register(SRCS "${SRCS}"
                         INCLUDE_DIRS "${INCLUDE_DIRS}"
                         # 如果有任何特殊的编译定义 (compile definitions)
                         # PRIV_REQUIRES esp-nn # 如果用到了 ESP-NN 优化
                        )
   
   # 如果您的 Edge Impulse 模型或 SDK 使用了 ESP-NN 库进行 ESP32 硬件加速
   # （这在 ESP32 上很常见，特别是对于量化模型），您可能需要添加对 esp-nn 组件的依赖。
   # 这可以通过在上面的 idf_component_register 中添加 PRIV_REQUIRES esp-nn 来实现，
   # 或者确保 esp-nn 已经包含在您的主项目CMakeLists.txt的 `REQUIRES` 或 `PRIV_REQUIRES` 中。
   # 对于 ESP-IDF v5.x, ESP-NN 通常作为标准组件提供。
   # 确保在 Edge Impulse SDK 的 porting 文件中选择了正确的平台 (espressif)
   # 位于 edge-impulse-sdk/porting/espressif/
   # 可能需要设置一些宏定义来启用 ESP-NN，例如 EI_CLASSIFIER_TFLITE_ENABLE_ESP_NN = 1
   # 这通常在 edge_impulse_sdk/classifier/ei_classifier_config.h 中或者通过编译选项设置
   target_compile_definitions(${COMPONENT_LIB} PRIVATE
       # 根据您的模型类型和配置添加必要的宏定义
       # 例如，如果使用 ESP-NN:
       # EI_CLASSIFIER_TFLITE_ENABLE_ESP_NN=1
       # 如果模型是 int8 量化的:
       # EIDSP_QUANTIZE_NONE=0 # 或者其他适当的量化设置
       # 如果是浮点模型:
       # EIDSP_USE_CMSIS_DSP=1 # 如果使用了CMSIS-DSP
       # EI_CLASSIFIER_TFLITE_INPUT_DATATYPE=DT_FLOAT32 # 示例
       # EI_CLASSIFIER_TFLITE_OUTPUT_DATATYPE=DT_FLOAT32 # 示例
       # ... 其他必要的宏
   )
   ```

   **重要提示关于 `SRCS` (源文件列表):**

   - 您需要仔细查看 `pinocchio2/wake_up-v3/wake_up-v3-06511904c4b6de119b71feb9fbb13c93ecc35929/edge-impulse-sdk/sources.txt` 和 `pinocchio2/wake_up-v3/wake_up-v3-06511904c4b6de119b71feb9fbb13c93ecc35929/edge-impulse-sdk/CMSIS/sources.txt` 这两个文件。
   - 这两个 `sources.txt` 列出了 Edge Impulse SDK 和 CMSIS 库需要编译的源文件（`.c` 或 `.cpp`）。您需要将这些文件路径（相对于 `edge_impulse_lib` 目录）添加到上面 `CMakeLists.txt` 的 `EI_SDK_SRCS` 和 `CMSIS_SRCS` 变量中。
   - **不是所有 `sources.txt` 中列出的文件都必须添加**，特别是 CMSIS 库非常庞大。通常只添加实际被您的模型和 DSP 处理块所用到的那些文件。一个好的起点是先包含 Edge Impulse SDK 的 `sources.txt` 中的大部分 C++ 文件，然后根据编译错误逐步添加 CMSIS 中缺失的部分。
   - 您上传的 `pinocchio2/wake_up-v3/wake_up-v3-06511904c4b6de119b71feb9fbb13c93ecc35929/tflite-model/tflite_learn_3_compiled.cpp` 是您的 TFLite 模型文件，也需要加入编译。

4. 在主程序中调用:

   在您的 xiaozhi-esp32/main/ 目录下的主程序文件（通常是 main.c 或您自己创建的 .cpp 文件）中：

   - 包含 Edge Impulse 的分类器头文件，通常是：

     C

     ```
     #include "edge_impulse_lib/edge-impulse-sdk/classifier/ei_run_classifier.h"
     // 或者如果你的 INCLUDE_DIRS 设置正确，可以直接是：
     // #include "ei_run_classifier.h"
     ```

   - 之后您就可以根据 Edge Impulse 提供的 API 来加载数据、运行模型推理了。具体使用方法请参考 Edge Impulse 官方文档或者您导出的项目中的示例代码。

5. **编译和调试**:

   - 回到 `xiaozhi-esp32` 项目的根目录。
   - 运行 `idf.py build` (或者 `idf.py reconfigure` 后再 `idf.py build`)。
   - 仔细查看编译输出。很可能会因为缺少某些源文件、头文件路径不正确或缺少宏定义而出现编译错误。根据错误信息，返回修改 `xiaozhi-esp32/components/edge_impulse_lib/CMakeLists.txt` 或检查文件复制是否正确。
   - 特别是 ESP32 的 Tensilica Xtensa 指令集与 ARM 不同，CMSIS-NN/DSP 库中的某些 ARM 优化代码可能不适用或需要特定于 Xtensa 的版本（ESP-IDF 通常通过 `esp-nn` 组件提供这些优化）。确保 `edge_impulse_sdk/classifier/ei_classifier_config.h` 中的配置适合 ESP32。Edge Impulse 导出的 ESP32 项目通常已经处理了这些配置。

**关于宏定义 (target_compile_definitions):**

在组件的 `CMakeLists.txt` 中，`target_compile_definitions` 部分非常重要。您可能需要添加一些宏来正确配置 Edge Impulse SDK：

- `EI_CLASSIFIER_TFLITE_ENABLE_ESP_NN=1`：如果您的模型希望使用 ESP-NN 进行硬件加速（推荐）。
- `EI_CLASSIFIER_TFLITE_ENABLE_NNOM=0`：（通常默认，除非您用的是 NNOM）
- `EI_CLASSIFIER_SENSOR`: 根据您的传感器类型定义，例如 `EI_CLASSIFIER_SENSOR_MICROPHONE`。
- 输入输出数据类型：例如 `EI_CLASSIFIER_TFLITE_INPUT_DATATYPE=DT_INT8` 或 `DT_FLOAT32`。
- 其他在 `edge_impulse_sdk/classifier/ei_classifier_config.h` 中提到的可配置宏。

**简化版 `CMakeLists.txt` 示例的思路：**

与其手动从 `sources.txt` 一个个复制，更稳妥的方式是先尝试包含主要的 SDK 文件和你的模型文件，然后根据编译错误来补充缺失的 CMSIS 文件。对于 DSP 和 NN 部分，优先使用 ESP-IDF 自带的 `esp-dsp` 和 `esp-nn` 组件（如果 Edge Impulse SDK 能够配置为使用它们的话），或者确保 Edge Impulse SDK 内部的 CMSIS 版本与 ESP32 兼容。

